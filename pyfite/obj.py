import numpy as np
import os
import re
import shutil
from .crs import *
from collections import namedtuple
from io import TextIOWrapper
from pathlib import Path
from typing import List, Optional, Set, Tuple, Union
from .util import DECIMAL_REGEX


class ContextCaptureMetadata(object):
    """A convenience class for interacting with metadata.xml files generated by ContextCapture.

    Note:
        This class does not guarantee tracking of all information in a metadata.xml.
        It is only guaranteed to track the <SRS> and <SRSOrigin> tags and enough of the DOM
        to be able to recreate a minimal metadata.xml should those tags be altered.

    Args:
        path (Union[str, Path]): The path to the metadata.xml to parse
    """
    __enuRegex = f'<SRS>ENU:({DECIMAL_REGEX}),({DECIMAL_REGEX})</SRS>'
    __geodeticRegex = '<SRS>EPSG:4326</SRS>'
    __offsetRegex = f'<SRSOrigin>({DECIMAL_REGEX}),({DECIMAL_REGEX}),({DECIMAL_REGEX})</SRSOrigin>'

    def __init__(self, path: Union[str, Path]):
        self._crs = None

        with open(path, 'r') as f:
            metadata = f.read()

            # Find the offset, which is present for all coordinate systems
            offset = (0.0, 0.0, 0.0)
            m = re.search(ContextCaptureMetadata.__offsetRegex, metadata)
            if m:
                offset = (float(m[1]), float(m[2]), float(m[3]))

            # First check to see if this is an ENU metadata.xml
            m = re.search(ContextCaptureMetadata.__enuRegex, metadata)
            if m:
                lat, lon = float(m[1]), float(m[2])
                self._crs = LocalTangentPlane(lon, lat, 0.0, offset)
                return

            # Next check to see if this is a geodetic metadata.xml
            m = re.search(ContextCaptureMetadata.__geodeticRegex, metadata)
            if m:
                self._crs = Geodetic(offset)

    def getOffset(self) -> Tuple[float, float, float]:
        """Gets the offset specified by the metadata.xml.

        Returns:
            Tuple[float,float,float]: The offset specified in the metadata.xml
        """
        return self._crs.offset

    def setOffset(self, offset: Tuple[float, float, float]) -> None:
        """Sets the offset.

        Args:
            offset (Tuple[float,float,float]): The offset the metadata should now assume
        """
        self._crs.offset = offset

    def getCrs(self) -> CoordinateReferenceSystem:
        """Gets the CoordinateReferenceSystem represented by a ContextCaptureMetadata.

        Returns:
            CoordinateReferenceSystem: The CoordinateReferenceSystem parsed from the metadata.xml
        """
        return self._crs

    def setCrs(self, crs: CoordinateReferenceSystem) -> None:
        """Sets the CoordinateReferenceSystem.

        Args:
            crs (CoordinateReferenceSystem): The CoordinateReferenceSystem the metadata should now assume
        """
        self._crs = crs

    def write(self, path: Union[str, Path]) -> None:
        """Writes the metadata out to ``path``.

        Warn:
            This method may lost information present in the original metadata.xml. It is only guaranteed
            to track Coordinate Reference System information.

        Note: It is assumed that all parents of ``path`` already exist.

        Args:
            path (Union[str,Path]): The path to write to
        """
        raise RuntimeError('ContextCaptureMetadata.write not implemented')


class Obj:
    """Supports reading and writing of .obj files

    Material definitions and texture files are tracked and copied to output
    directories on writes. Additionally, if a base CoordinateReferenceSystem
    is provided, Objs can be converted to other CoordinateReferenceSystems.

    Args:
        path (Union[Path,str], optional): The path to an .obj to read
        crs (CoordinateReferenceSystem, optional): The underlying CRS of the Obj

    Raises:
        FileNotFoundError: The ``path``, if specified, does not exist
    """

    __INV_IDX = np.uint32(-1)

    MtlLib = namedtuple('MtlLib', ['base', 'relative'])  # [Path, Union[str,Path]]

    def __init__(self, path: Optional[Union[str, Path]] = None, crs: CoordinateReferenceSystem = None):
        self._crs = crs
        self.vertices = np.empty((0, 3), dtype=np.float32)
        self.texCoords = np.empty((0, 2), dtype=np.float32)
        self.normals = np.empty((0, 3), dtype=np.float32)
        self.faces = np.empty((0, 3, 3), dtype=np.uint32)
        self.materials: List[List[Obj.MtlLib, str, int]] = []  # [mtllib, material, ending idx]
        self.__root: Path = None
        self.__have_tex, self.__have_norm = False, False

        if (path):
            if os.path.isfile(path):
                self.read(path)
            else:
                raise FileNotFoundError(f'{path} does not exist')

    def read(self, path: Union[str, Path]) -> None:
        """
        """

        if isinstance(path, str):
            path = Path(path)
        self.__root = path.parent

        # First get a count of everything we need to store
        f = open(path, 'r')
        content = f.readlines()
        f.close()

        counts = {'v': 0, 'vt': 0, 'vn': 0, 'f': 0, 'usemtl': 0, 'mtllib': 0}
        for line in content:
            key = line[:line.find(' ')]
            if key in counts:
                counts[key] += 1

        self.vertices = np.empty((counts['v'], 3), dtype=np.float32)
        self.texCoords = np.empty((counts['vt'], 2), dtype=np.float32)
        self.normals = np.empty((counts['vn'], 3), dtype=np.float32)
        self.faces = np.empty((counts['f'], 3, 3), dtype=np.uint32)

        v, vt, vn, f = 0, 0, 0, 0
        mtllib = ''
        mtl = ''
        for line in content:
            tokens = line.split()
            attribute = tokens[0]

            if attribute == 'v':
                self.vertices[v] = (np.float32(tokens[1]), np.float32(tokens[2]), np.float32(tokens[3]))
                v += 1

            elif attribute == 'vt':
                self.texCoords[vt] = (np.float32(tokens[1]), np.float32(tokens[2]))
                vt += 1

            elif attribute == 'vn':
                self.normals[vn] = (np.float32(tokens[1]), np.float32(tokens[2]), np.float32(tokens[3]))
                vn += 1

            elif attribute == 'mtllib':
                mtllib = tokens[1]
                self.__recordMatChange(mtllib, mtl, f)

            elif attribute == 'usemtl':
                mtl = tokens[1]
                self.__recordMatChange(mtllib, mtl, f)

            elif attribute == 'f':
                for i, token in enumerate(tokens[1:]):
                    v = [Obj.__INV_IDX] * 3
                    for j, val in enumerate(token.split('/')):
                        if val:
                            v[j] = int(val)
                    self.faces[f][i] = v
                f += 1

        # Clear out an empty material if it happened to happen at the end
        if (len(self.materials) >= 2 and self.materials[-1][2] == self.materials[-2][2] or len(self.materials) and self.materials[-1][2] == len(self.faces)):
            self.materials.pop()

        [_, self.__have_tex, self.__have_norm] = np.any(np.apply_along_axis(
            lambda x: any(y != Obj.__INV_IDX for y in x), 0, self.faces), 0)

    def write(self, dest: Union[str, Path, TextIOWrapper]) -> None:
        """
        """
        if isinstance(dest, str):
            dest = Path(dest)

        if isinstance(dest, TextIOWrapper):
            self._writeV(dest)
            self._writeVt(dest)
            self._writeVn(dest)
            self._writeF(dest)
            destParent = Path(dest.name).parent
        else:
            destParent = dest.Parent
            os.makedirs(dest.parent, exist_ok=True)
            with open(dest, 'w+', 8192) as obj:
                self._writeV(obj)
                self._writeVt(obj)
                self._writeVn(obj)
                self._writeF(obj)

        self._copyMaterials(destParent)

    def _writeV(self, fout) -> None:
        """
        """
        for v in self.vertices:
            fout.write(f'v {v[0]} {v[1]} {v[2]}\n')

    def _writeVt(self, fout) -> None:
        """
        """
        for vt in self.texCoords:
            fout.write(f'vt {vt[0]} {vt[1]}\n')

    def _writeVn(self, fout) -> None:
        """
        """
        for vn in self.normals:
            fout.write(f'vn {vn[0]} {vn[1]} {vn[2]}\n')

    def _writeF(self, fout) -> None:
        """
        """
        i = 0
        mtllib, mtl = '', ''
        mat_gen = (mat for mat in self.materials)

        vert_pattern = '{}'
        if self.__have_norm:
            vert_pattern += '/{}/{}'
        elif self.__have_tex:
            vert_pattern += '/{}{}'  # Second brace will always be filled with ''
        else:
            vert_pattern += '{}{}'  # Second and third braces always filled with ''

        while i < len(self.faces):
            stop = len(self.faces)
            matlines = []
            try:
                next_mat = next(mat_gen)
                if next_mat[0] != mtllib:
                    mtllib = next_mat[0]
                    matlines.append(f'mtllib {str(mtllib.relative)}\n')
                if next_mat[1] != mtl:
                    mtl = next_mat[1]
                    matlines.append(f'usemtl {mtl}\n')
                stop = next_mat[2]
            except StopIteration:
                pass

            # First write out the faces of the lines for the current mat
            for j in range(i, stop):
                face = map(lambda x: str(x) if x != Obj.__INV_IDX else '', self.faces[j].reshape((9,)))
                fout.write(f'f {vert_pattern} {vert_pattern} {vert_pattern}\n'.format(*face))

            # Then write the mtllib and usemtl lines for the next material in the list
            fout.write(''.join(matlines))
            i = stop

    def _copyMaterials(self, base: Path) -> None:
        """
        """
        mtllibs = set([m[0] for m in self.materials])
        for mtllib in mtllibs:
            with open(mtllib.base / mtllib.relative, 'r') as m:
                content = m.read()
                materials = [line.rstrip()[len('map_Kd '):] for line in content.split('\n') if line.startswith('map_Kd')]
                for material in materials:
                    mat_src = (mtllib.base / mtllib.relative).parent / material
                    mat_dst = (base / mtllib.relative).parent / material
                    os.makedirs(mat_dst.parent, exist_ok=True)
                    shutil.copy(mat_src, mat_dst)

                mtllib_dst = base / mtllib.relative
                os.makedirs(mtllib_dst.parent, exist_ok=True)
                with open(mtllib_dst, 'w+') as n:
                    n.write(content)

    def combine(self, other: 'Obj') -> None:
        """
        """
        if not isinstance(other, Obj):
            raise RuntimeError(f"Cannot combine {type(self)} with type {type(other)}")

        if self._crs != other._crs:
            # TODO(rhite): convert other to self automatically?
            raise RuntimeError(f"Cannot combine objs with differing coordinate systems")

        if not self.__root:
            # Started with an empty obj that didn't call read(...)
            self.__root = other.__root

        o_v_count = np.uint32(len(self.vertices))
        o_vt_count = np.uint32(len(self.texCoords))
        o_vn_count = np.uint32(len(self.normals))
        o_f_count = np.uint32(len(self.faces))

        self.vertices = np.concatenate((self.vertices, other.vertices))
        self.texCoords = np.concatenate((self.texCoords, other.texCoords))
        self.normals = np.concatenate((self.normals, other.normals))

        self.faces = np.concatenate((self.faces, other.faces + [o_v_count, o_vt_count, o_vn_count]))
        self.materials = self.materials + [(m[0], m[1], m[2] + o_f_count) for m in other.materials]

        self.__have_tex |= other.__have_tex
        self.__have_norm |= other.__have_norm

    def getCrs(self) -> CoordinateReferenceSystem:
        """
        """
        return self._crs

    def setCrs(self, crs: CoordinateReferenceSystem) -> None:
        """
        """
        self._crs = crs

    def convert(self, toCrs: CoordinateReferenceSystem) -> None:
        """
        """
        self.vertices = CoordinateConverter(self._crs, toCrs)(self.vertices)
        self._crs = toCrs
        # TODO(rhite): Handle normals

    def __recordMatChange(self, mtllib, mtl, f):
        """
        """
        if mtllib and mtl:
            mtllib = Obj.MtlLib(self.__root, mtllib)
            if len(self.materials) and self.materials[-1][2] == f:
                self.materials[-1] = [mtllib, mtl, f]
            else:
                self.materials.append([mtllib, mtl, f])


class AittObj(Obj):
    """An implementation of Obj specific for AITT outputs.
    """
    def write(self, dest: Union[str, Path, TextIOWrapper]) -> None:
        if not self._crs:
            raise RuntimeError("Cannot write AittObj with no original CoordinateReferenceSystem")

        if not isinstance(self._crs, Geocentric):
            self.convert(Geocentric())

        # Calculate the target CRS by offsetting to the center of gravity of the Obj
        targetCrs = Geocentric(tuple(np.floor(np.mean(self.vertices, axis=0))))
        self.convert(targetCrs)

        if isinstance(dest, str) or isinstance(dest, Path):
            dest = open(dest, 'w+', 8192)
            dest.write("# GCC Offset (local origin) : {} {} {}\n".format(*self._crs.offset))

        super().write(dest)
        dest.close()
